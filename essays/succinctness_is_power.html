<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Succinctness is Power - Paul Graham Essays</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
    <style>
        .dark-mode { background-color: #1a202c; color: #e2e8f0; }
        .dark-mode header, .dark-mode nav, .dark-mode .bg-white { background-color: #2d3748; color: #e2e8f0; }
        .dark-mode h1, .dark-mode h2, .dark-mode h3 { color: #f7fafc; }
        .dark-mode p, .dark-mode .text-gray-600, .dark-mode .text-gray-500 { color: #cbd5e0; }
        .dark-mode .border-gray-200 { border-color: #4a5568; }
        .dark-mode .shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2); }

        .essay-content { font-family: Georgia, serif; line-height: 1.8; font-size: 1.125rem; }
        .essay-content h1, .essay-content h2, .essay-content h3 { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin-top: 2rem; margin-bottom: 1rem; }
        .essay-content p { margin-bottom: 1.5rem; }
        .essay-content a { color: #4f46e5; text-decoration: underline; }
        .essay-content a:hover { color: #4338ca; }
        .essay-content blockquote { border-left: 4px solid #e5e7eb; padding-left: 1rem; font-style: italic; margin: 1.5rem 0; }
        .dark-mode .essay-content blockquote { border-left-color: #4a5568; }

        .font-size-controls button { padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; font-size: 0.875rem; }
        .font-size-controls button.active { background-color: #4f46e5; color: white; }
        .dark-mode .font-size-controls button.active { background-color: #6366f1; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <header class="bg-white shadow">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">Paul Graham Essays</h1>
                    <p class="mt-2 text-gray-600">A collection of essays by Paul Graham, co-founder of Y Combinator</p>
                </div>
                <div>
                    <button id="theme-toggle" class="p-2 rounded-md text-gray-500 hover:text-gray-700 focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <nav class="bg-white shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex">
                    <div class="flex-shrink-0 flex items-center">
                        <a href="../index.html" class="text-gray-500 hover:text-gray-700">Home</a>
                    </div>
                    <div class="ml-6 flex space-x-8">
                        <a href="../essays.html" class="border-indigo-500 text-gray-900 hover:text-gray-900 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Essays
                        </a>
                        <a href="../download.html" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Download
                        </a>
                        <a href="../about.html" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            About
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <main class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <article>
            <header class="mb-8">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-indigo-600 bg-indigo-200">#016</span>
                    <span class="text-sm text-gray-500">November 2002</span>
                </div>
                <h1 class="text-3xl font-bold text-gray-900 mb-4">Succinctness is Power</h1>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-500">16 min read</span>
                    <a href="http://www.paulgraham.com/power.html" target="_blank" rel="noopener noreferrer" class="text-sm text-indigo-600 hover:text-indigo-800">Original Source ↗</a>
                </div>
            </header>

            <div class="font-size-controls mb-6 flex items-center">
                <span class="text-sm text-gray-500 mr-2">Font size:</span>
                <button class="text-sm" data-size="text-sm">Small</button>
                <button class="text-base active" data-size="text-base">Medium</button>
                <button class="text-lg" data-size="text-lg">Large</button>
            </div>

            <div class="essay-content text-base">
                <h1>016 Succinctness is Power</h1>
<p>May 2002   </p>
<p>"The quantity of meaning compressed into a small space by algebraic signs, is another circumstance that facilitates the reasonings we are accustomed to carry on by their aid."   </p>
<p>- Charles Babbage, quoted in Iverson's Turing Award Lecture   </p>
<p>In the discussion about issues raised by <a href="icad.html">Revenge of the Nerds</a> on the LL1 mailing list, Paul Prescod wrote something that stuck in my mind. </p>
<blockquote>
<p>Python's goal is regularity and readability, not succinctness. </p>
</blockquote>
<p>On the face of it, this seems a rather damning thing to claim about a programming language. As far as I can tell, succinctness = power. If so, then substituting, we get </p>
<blockquote>
<p>Python's goal is regularity and readability, not power. </p>
</blockquote>
<p>and this doesn't seem a tradeoff (if it <em>is</em> a tradeoff) that you'd want to make. It's not far from saying that Python's goal is not to be effective as a programming language.   </p>
<p>Does succinctness = power? This seems to me an important question, maybe the most important question for anyone interested in language design, and one that it would be useful to confront directly. I don't feel sure yet that the answer is a simple yes, but it seems a good hypothesis to begin with.   </p>
<p><strong>Hypothesis</strong>   </p>
<p>My hypothesis is that succinctness is power, or is close enough that except in pathological examples you can treat them as identical.   </p>
<p>It seems to me that succinctness is what programming languages are <em>for.</em> Computers would be just as happy to be told what to do directly in machine language. I think that the main reason we take the trouble to develop high- level languages is to get leverage, so that we can say (and more importantly, think) in 10 lines of a high-level language what would require 1000 lines of machine language. In other words, the main point of high-level languages is to make source code smaller.   </p>
<p>If smaller source code is the purpose of high-level languages, and the power of something is how well it achieves its purpose, then the measure of the power of a programming language is how small it makes your programs.   </p>
<p>Conversely, a language that doesn't make your programs small is doing a bad job of what programming languages are supposed to do, like a knife that doesn't cut well, or printing that's illegible.   </p>
<p><strong>Metrics</strong>   </p>
<p>Small in what sense though? The most common measure of code size is lines of code. But I think that this metric is the most common because it is the easiest to measure. I don't think anyone really believes it is the true test of the length of a program. Different languages have different conventions for how much you should put on a line; in C a lot of lines have nothing on them but a delimiter or two.   </p>
<p>Another easy test is the number of characters in a program, but this is not very good either; some languages (Perl, for example) just use shorter identifiers than others.   </p>
<p>I think a better measure of the size of a program would be the number of elements, where an element is anything that would be a distinct node if you drew a tree representing the source code. The name of a variable or function is an element; an integer or a floating-point number is an element; a segment of literal text is an element; an element of a pattern, or a format directive, is an element; a new block is an element. There are borderline cases (is -5 two elements or one?) but I think most of them are the same for every language, so they don't affect comparisons much.   </p>
<p>This metric needs fleshing out, and it could require interpretation in the case of specific languages, but I think it tries to measure the right thing, which is the number of parts a program has. I think the tree you'd draw in this exercise is what you have to make in your head in order to conceive of the program, and so its size is proportionate to the amount of work you have to do to write or read it.   </p>
<p><strong>Design</strong>   </p>
<p>This kind of metric would allow us to compare different languages, but that is not, at least for me, its main value. The main value of the succinctness test is as a guide in <em>designing</em> languages. The most useful comparison between languages is between two potential variants of the same language. What can I do in the language to make programs shorter?   </p>
<p>If the conceptual load of a program is proportionate to its complexity, and a given programmer can tolerate a fixed conceptual load, then this is the same as asking, what can I do to enable programmers to get the most done? And that seems to me identical to asking, how can I design a good language?   </p>
<p>(Incidentally, nothing makes it more patently obvious that the old chestnut "all languages are equivalent" is false than designing languages. When you are designing a new language, you're <em>constantly</em> comparing two languages-- the language if I did x, and if I didn't-- to decide which is better. If this were really a meaningless question, you might as well flip a coin.)   </p>
<p>Aiming for succinctness seems a good way to find new ideas. If you can do something that makes many different programs shorter, it is probably not a coincidence: you have probably discovered a useful new abstraction. You might even be able to write a program to help by searching source code for repeated patterns. Among other languages, those with a reputation for succinctness would be the ones to look to for new ideas: Forth, Joy, Icon.   </p>
<p><strong>Comparison</strong>   </p>
<p>The first person to write about these issues, as far as I know, was Fred Brooks in the <em>Mythical Man Month</em>. He wrote that programmers seemed to generate about the same amount of code per day regardless of the language. When I first read this in my early twenties, it was a big surprise to me and seemed to have huge implications. It meant that (a) the only way to get software written faster was to use a more succinct language, and (b) someone who took the trouble to do this could leave competitors who didn't in the dust.   </p>
<p>Brooks' hypothesis, if it's true, seems to be at the very heart of hacking. In the years since, I've paid close attention to any evidence I could get on the question, from formal studies to anecdotes about individual projects. I have seen nothing to contradict him.   </p>
<p>I have not yet seen evidence that seemed to me conclusive, and I don't expect to. Studies like Lutz Prechelt's comparison of programming languages, while generating the kind of results I expected, tend to use problems that are too short to be meaningful tests. A better test of a language is what happens in programs that take a month to write. And the only real test, if you believe as I do that the main purpose of a language is to be good to think in (rather than just to tell a computer what to do once you've thought of it) is what new things you can write in it. So any language comparison where you have to meet a predefined spec is testing slightly the wrong thing.   </p>
<p>The true test of a language is how well you can discover and solve new problems, not how well you can use it to solve a problem someone else has already formulated. These two are quite different criteria. In art, mediums like embroidery and mosaic work well if you know beforehand what you want to make, but are absolutely lousy if you don't. When you want to discover the image as you make it-- as you have to do with anything as complex as an image of a person, for example-- you need to use a more fluid medium like pencil or ink wash or oil paint. And indeed, the way tapestries and mosaics are made in practice is to make a painting first, then copy it. (The word "cartoon" was originally used to describe a painting intended for this purpose).   </p>
<p>What this means is that we are never likely to have accurate comparisons of the relative power of programming languages. We'll have precise comparisons, but not accurate ones. In particular, explicit studies for the purpose of comparing languages, because they will probably use small problems, and will necessarily use predefined problems, will tend to underestimate the power of the more powerful languages.   </p>
<p>Reports from the field, though they will necessarily be less precise than "scientific" studies, are likely to be more meaningful. For example, Ulf Wiger of Ericsson did a <a href="http://www.erlang.se/publications/Ulf_Wiger.pdf">study</a> that concluded that Erlang was 4-10x more succinct than C++, and proportionately faster to develop software in: </p>
<blockquote>
<p>Comparisons between Ericsson-internal development projects indicate similar &gt; line/hour productivity, including all phases of software development, rather &gt; independently of which language (Erlang, PLEX, C, C++, or Java) was used. &gt; What differentiates the different languages then becomes source code volume. </p>
</blockquote>
<p>The study also deals explictly with a point that was only implicit in Brooks' book (since he measured lines of debugged code): programs written in more powerful languages tend to have fewer bugs. That becomes an end in itself, possibly more important than programmer productivity, in applications like network switches.   </p>
<p><strong>The Taste Test</strong>   </p>
<p>Ultimately, I think you have to go with your gut. What does it feel like to program in the language? I think the way to find (or design) the best language is to become hypersensitive to how well a language lets you think, then choose/design the language that feels best. If some language feature is awkward or restricting, don't worry, you'll know about it.   </p>
<p>Such hypersensitivity will come at a cost. You'll find that you can't <em>stand</em> programming in clumsy languages. I find it unbearably restrictive to program in languages without macros, just as someone used to dynamic typing finds it unbearably restrictive to have to go back to programming in a language where you have to declare the type of every variable, and can't make a list of objects of different types.   </p>
<p>I'm not the only one. I know many Lisp hackers that this has happened to. In fact, the most accurate measure of the relative power of programming languages might be the percentage of people who know the language who will take any job where they get to use that language, regardless of the application domain.   </p>
<p><strong>Restrictiveness</strong>   </p>
<p>I think most hackers know what it means for a language to feel restrictive. What's happening when you feel that? I think it's the same feeling you get when the street you want to take is blocked off, and you have to take a long detour to get where you wanted to go. There is something you want to say, and the language won't let you.   </p>
<p>What's really going on here, I think, is that a restrictive language is one that isn't succinct enough. The problem is not simply that you can't say what you planned to. It's that the detour the language makes you take is <em>longer.</em> Try this thought experiment. Suppose there were some program you wanted to write, and the language wouldn't let you express it the way you planned to, but instead forced you to write the program in some other way that was <em>shorter.</em> For me at least, that wouldn't feel very restrictive. It would be like the street you wanted to take being blocked off, and the policeman at the intersection directing you to a shortcut instead of a detour. Great!   </p>
<p>I think most (ninety percent?) of the feeling of restrictiveness comes from being forced to make the program you write in the language longer than one you have in your head. Restrictiveness is mostly lack of succinctness. So when a language feels restrictive, what that (mostly) means is that it isn't succinct enough, and when a language isn't succinct, it will feel restrictive.   </p>
<p><strong>Readability</strong>   </p>
<p>The quote I began with mentions two other qualities, regularity and readability. I'm not sure what regularity is, or what advantage, if any, code that is regular and readable has over code that is merely readable. But I think I know what is meant by readability, and I think it is also related to succinctness.   </p>
<p>We have to be careful here to distinguish between the readability of an individual line of code and the readability of the whole program. It's the second that matters. I agree that a line of Basic is likely to be more readable than a line of Lisp. But a program written in Basic is is going to have more lines than the same program written in Lisp (especially once you cross over into Greenspunland). The total effort of reading the Basic program will surely be greater. </p>
<blockquote>
<p>total effort = effort per line x number of lines </p>
</blockquote>
<p>I'm not as sure that readability is directly proportionate to succinctness as I am that power is, but certainly succinctness is a factor (in the mathematical sense; see equation above) in readability. So it may not even be meaningful to say that the goal of a language is readability, not succinctness; it could be like saying the goal was readability, not readability.   </p>
<p>What readability-per-line does mean, to the user encountering the language for the first time, is that source code will <em>look unthreatening</em>. So readability- per-line could be a good marketing decision, even if it is a bad design decision. It's isomorphic to the very successful technique of letting people pay in installments: instead of frightening them with a high upfront price, you tell them the low monthly payment. Installment plans are a net lose for the buyer, though, as mere readability-per-line probably is for the programmer. The buyer is going to make a <em>lot</em> of those low, low payments; and the programmer is going to read a <em>lot</em> of those individually readable lines.   </p>
<p>This tradeoff predates programming languages. If you're used to reading novels and newspaper articles, your first experience of reading a math paper can be dismaying. It could take half an hour to read a single page. And yet, I am pretty sure that the notation is not the problem, even though it may feel like it is. The math paper is hard to read because the ideas are hard. If you expressed the same ideas in prose (as mathematicians had to do before they evolved succinct notations), they wouldn't be any easier to read, because the paper would grow to the size of a book.   </p>
<p><strong>To What Extent?</strong>   </p>
<p>A number of people have rejected the idea that succinctness = power. I think it would be more useful, instead of simply arguing that they are the same or aren't, to ask: to what <em>extent</em> does succinctness = power? Because clearly succinctness is a large part of what higher-level languages are for. If it is not all they're for, then what else are they for, and how important, relatively, are these other functions?   </p>
<p>I'm not proposing this just to make the debate more civilized. I really want to know the answer. When, if ever, is a language too succinct for its own good?   </p>
<p>The hypothesis I began with was that, except in pathological examples, I thought succinctness could be considered identical with power. What I meant was that in any language anyone would design, they would be identical, but that if someone wanted to design a language explicitly to disprove this hypothesis, they could probably do it. I'm not even sure of that, actually.   </p>
<p><strong>Languages, not Programs</strong>   </p>
<p>We should be clear that we are talking about the succinctness of languages, not of individual programs. It certainly is possible for individual programs to be written too densely.   </p>
<p>I wrote about this in <a href="onlisp.html">On Lisp</a>. A complex macro may have to save many times its own length to be justified. If writing some hairy macro could save you ten lines of code every time you use it, and the macro is itself ten lines of code, then you get a net saving in lines if you use it more than once. But that could still be a bad move, because macro definitions are harder to read than ordinary code. You might have to use the macro ten or twenty times before it yielded a net improvement in readability.   </p>
<p>I'm sure every language has such tradeoffs (though I suspect the stakes get higher as the language gets more powerful). Every programmer must have seen code that some clever person has made marginally shorter by using dubious programming tricks.   </p>
<p>So there is no argument about that-- at least, not from me. Individual programs can certainly be too succinct for their own good. The question is, can a language be? Can a language compel programmers to write code that's short (in elements) at the expense of overall readability?   </p>
<p>One reason it's hard to imagine a language being too succinct is that if there were some excessively compact way to phrase something, there would probably also be a longer way. For example, if you felt Lisp programs using a lot of macros or higher-order functions were too dense, you could, if you preferred, write code that was isomorphic to Pascal. If you don't want to express factorial in Arc as a call to a higher-order function  (rec zero 1 * 1-)  you can also write out a recursive definition:  (rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))  Though I can't off the top of my head think of any examples, I am interested in the question of whether a language could be too succinct. Are there languages that force you to write code in a way that is crabbed and incomprehensible? If anyone has examples, I would be very interested to see them.   </p>
<p>(Reminder: What I'm looking for are programs that are very dense according to the metric of "elements" sketched above, not merely programs that are short because delimiters can be omitted and everything has a one-character name.)   </p>
<p><a href="http://www.shiro.dreamhost.com/scheme/trans/power-j.html">Japanese Translation</a>   </p>
<p><a href="http://www.melikyan.com/dalshe/articles/power.html">Russian Translation</a>   </p>
<p><a href="http://wwwipd.ira.uka.de/~prechelt/Biblio/jccpprtTR.pdf">Lutz Prechelt: Comparison of Seven Languages</a>   </p>
<p><a href="http://www.flownet.com/gat/papers/lisp-java.pdf">Erann Gat: Lisp vs. Java</a>   </p>
<p><a href="http://www.norvig.com/java-lisp.html">Peter Norvig Tries Prechelt's Test</a>   </p>
<p><a href="http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz">Matthias Felleisen: Expressive Power of Languages</a>   </p>
<p><a href="redund.html">Kragen Sitaker: Redundancy and Power</a>   </p>
<p><a href="http://www.colorforth.com/">Forth</a>   </p>
<p><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">Joy</a>   </p>
<p><a href="http://www.cs.arizona.edu/icon/">Icon</a>   </p>
<p><a href="http://www.jsoftware.com/books/help/primer/contents.htm">J</a>   </p>
<p><a href="http://www.cosy.com/language/k-lang.htm">K</a>   </p>
<hr />
            </div>

            <div class="mt-12 pt-8 border-t border-gray-200">
                <div class="flex flex-col sm:flex-row sm:justify-between">
                    <a href="016_succinctness_is_power.md" download="succinctness_is_power.md" class="mb-4 sm:mb-0 inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        Download Essay
                    </a>
                    <a href="../essays.html" class="inline-flex items-center px-4 py-2 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                        Browse More Essays
                    </a>
                </div>
            </div>
        </article>
    </main>

    <footer class="bg-white border-t border-gray-200">
        <div class="max-w-7xl mx-auto py-12 px-4 overflow-hidden sm:px-6 lg:px-8">
            <p class="text-center text-base text-gray-500">
                All essays are property of © Paul Graham. This website is not affiliated with Paul Graham.
            </p>
            <p class="text-center text-sm text-gray-500 mt-2">
                Based on the <a href="https://github.com/ofou/graham-essays" class="text-indigo-600 hover:text-indigo-800">graham-essays</a> repository.
            </p>
        </div>
    </footer>

    <script>
        // Theme and font size controls
        document.addEventListener('DOMContentLoaded', function() {
            // Theme toggle
            var themeToggle = document.getElementById('theme-toggle');
            var prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

            var currentTheme = localStorage.getItem('theme') ||
                             (prefersDarkScheme.matches ? 'dark' : 'light');

            if (currentTheme === 'dark') {
                document.body.classList.add('dark-mode');
                updateThemeIcon(true);
            } else {
                document.body.classList.remove('dark-mode');
                updateThemeIcon(false);
            }

            themeToggle.addEventListener('click', function() {
                var isDarkMode = document.body.classList.toggle('dark-mode');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                updateThemeIcon(isDarkMode);
            });

            // Font size controls
            var fontSizeButtons = document.querySelectorAll('.font-size-controls button');
            var essayContent = document.querySelector('.essay-content');

            fontSizeButtons.forEach(function(button) {
                button.addEventListener('click', function() {
                    fontSizeButtons.forEach(function(btn) {
                        btn.classList.remove('active');
                    });

                    this.classList.add('active');
                    var fontSize = this.getAttribute('data-size');

                    essayContent.classList.remove('text-sm', 'text-base', 'text-lg');
                    essayContent.classList.add(fontSize);
                });
            });
        });

        function updateThemeIcon(isDarkMode) {
            var themeToggle = document.getElementById('theme-toggle');

            if (isDarkMode) {
                themeToggle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>';
            } else {
                themeToggle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>';
            }
        }
    </script>
</body>
</html>
